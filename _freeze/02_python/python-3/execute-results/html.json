{
  "hash": "f656480717ffb915ef7417f04870f7ff",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: '3. Functions, documentation, strings, files'\njupyter: python3\n---\n\n# Functions\n\n## What are functions?\n\n- A **Function** is a named sequence of statements which accomplish a task. They promote modularity, making our code less complex, easier to understand and encourage code-reuse.\n- When you “run” a defined function it’s known as a **function call**. Functions are designed to be ***written once***, but ***called many times***.\n- We've seen functions before:  \n\n::: {#3d7d8675 .cell tags='[]' execution_count=1}\n``` {.python .cell-code}\n# We call functions all the time\n# input(). random.randint(), and int() are all functions!\nimport random\nx = input(\"Enter Name: \")  \ny = random.randint(1, 10)  #random is the module, randint() is the function\nz = int(\"9\")\nprint(x, y, z)\n```\n:::\n\n\n## Function Definitions\n\nFunctions are like their own little programs. They take input, which we call the **function arguments (or parameters)** and give us back output that we refer to as **return values**.\n\n```\nINPUT      ==> PROCESS     ==> OUTPUT\nFunction   ==> Function    ==> Function \nArguments      Definition       Return\n```\n\nWe use the `def` keyword to define a function.\n\n::: {#f442ceec .cell tags='[]' execution_count=2}\n``` {.python .cell-code}\n# Example Function\ndef area_of_triangle(base, height): # <== INPUTs\n    area = 0.5 * base * height\n    return area # <== OUTPUT\n\n# Function call: using your function\na = area_of_triangle(10, 5)\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25.0\n```\n:::\n:::\n\n\nWhen you call a function you can name your arguments. This allows you to override the order of the arguments.\n\n::: {#54e99851 .cell tags='[]' execution_count=3}\n``` {.python .cell-code}\n# These are the same order as defined\narea1 = area_of_triangle(base = 10, height = 5)\n# Different order than defined\narea2 = area_of_triangle(height = 5, base = 10)\nprint(area1, area2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n25.0 25.0\n```\n:::\n:::\n\n\n### Multiple Return Values\n\n::: {#833588e8 .cell execution_count=4}\n``` {.python .cell-code}\ndef division_and_modulo(dividend, divisor):\n    quotient = dividend // divisor # int division\n    remainder = dividend % divisor # modulo\n    return quotient, remainder\n\nq, r = division_and_modulo(10, 3)\nprint(f\"10 divided by 3 is {q}, with a remainder of {r}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 divided by 3 is 3, with a remainder of 1\n```\n:::\n:::\n\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 3.1\n\nWrite a function called `average` which takes a list of numbers as input then outputs the average of the numbers sum / count\n\nCall your function with an arbitrary list of numbers you create.\n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n::: {#548acebe .cell execution_count=5}\n``` {.python .cell-code}\ndef average(list_of_numbers):\n    total = 0\n    count = 0\n    for n in list_of_numbers:\n        total += n\n        count += 1\n    return total/count\n\nnums = [10, 15, 10, 5]\navg = average(nums)\nprint(f\"Average of {nums} is {avg}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAverage of [10, 15, 10, 5] is 10.0\n```\n:::\n:::\n\n\n:::\n::::\n\n## Type Hints\n\nTypes can be added to the `def` statement to help the caller understand what type of data the function expects. These are known as **type hints**\n\nIn this example the expected arguments are `float` and the return is `float`\n\n::: {#474529dc .cell tags='[]' execution_count=6}\n``` {.python .cell-code}\ndef area_of_triangle(base: float, height: float) -> float: \n    area = 0.5 * base *height\n    return area\n```\n:::\n\n\nYou can see type hints in action by calling the function\n\nRun the cell above to create the function.  \nIn the code below, start a left paren `(` to see the type hints\n\n::: {#e9768bba .cell execution_count=7}\n``` {.python .cell-code}\narea_of_triangle\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n<function __main__.area_of_triangle(base: float, height: float) -> float>\n```\n:::\n:::\n\n\n## Docstrings\n\nA **Docstring** is a  multi-line comment which explains what the function does to the function caller.\n\nThe same function with type hints and docstring:\n\n::: {#5197d053 .cell tags='[]' execution_count=8}\n``` {.python .cell-code}\ndef area_of_triangle(base: float, height: float) -> float: \n    '''\n    Calculates the area of a triangle given base and height\n    returns the area defined as 1/2 the base times height\n    '''\n    area = 0.5 * base *height\n    return area\n```\n:::\n\n\nYou can see doc strings in action by calling the function\n\nRun the cell above to create the function.\nIn the code below, start a left paren `(` to see the doc string\n\n::: {#66d36d88 .cell execution_count=9}\n``` {.python .cell-code}\narea_of_triangle\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n<function __main__.area_of_triangle(base: float, height: float) -> float>\n```\n:::\n:::\n\n\nYou can also use `?` or `help()` to see the docstring and type hints:\n\n::: {#b15335ab .cell execution_count=10}\n``` {.python .cell-code}\nhelp(area_of_triangle)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHelp on function area_of_triangle in module __main__:\n\narea_of_triangle(base: float, height: float) -> float\n    Calculates the area of a triangle given base and height\n    returns the area defined as 1/2 the base times height\n\n```\n:::\n:::\n\n\n# Strings\n\n## Strings are sequence types\n\nYou can use slice notation like with lists.\n\nThese are zero based.\n\n`var[start:stop]`\n\nTakes `stop - start` characters from `var` starting at position `start`\n\n::: {#1e7f6537 .cell tags='[]' execution_count=11}\n``` {.python .cell-code}\nx = \"fudge\"\nprint(x[0:2]) # fu\nprint(x[2:5]) # dge\nprint(x[:4]) # fudg\nprint(x[:]) # fudge\nprint(x[:-1]) # fudg\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfu\ndge\nfudg\nfudge\nfudg\n```\n:::\n:::\n\n\n## String Methods\n\n<https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str>\n\nMethod functions attach to the string   `x.strip()`\n\nCommon methods\n```\nstrip()\nupper()\nlower()\nfind()\ncount()\nsplit()\njoin()\nreplace()\n```\n\n::: {#99203a24 .cell tags='[]' execution_count=12}\n``` {.python .cell-code}\n# Samples\ns = \"this is a test\"\nprint(s.count(\"is\")) # 2\nprint(s.count(\"t\"))  # 3\nprint(s.upper()[:4]) # TEST\nprint(s.find(\" a \")) # 7\nprint(s.find(\"this\")) # 9\nprint(\"   x   \".strip()) # x\nprint(s.replace(\"this\", \"that\")) # that is a test\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n3\nTHIS\n7\n0\nx\nthat is a test\n```\n:::\n:::\n\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 3.2\n\nWrite a function called `cleanup` which takes a string as input and returns a \"cleaned string\" meaning:\n - remove any ? , . or !\n - strip off the whitespace from the ends\n - return text in lower case\n \nWrite code to call your function and test it\n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n::: {#7b33bb21 .cell execution_count=13}\n``` {.python .cell-code}\ndef cleanup(text: str) -> str:\n    for ch in \"!?,.\":\n        if ch in text:\n            text = text.replace(ch, \"\")\n    return text.lower().strip()\n\ntext = \"  THis! Is. , a tEST? \"\ncleaned = cleanup(text)\nprint(cleaned)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nthis is  a test\n```\n:::\n:::\n\n\n:::\n::::\n\n## String Tokenization and Parsing\n\n- **Tokenization**  is the process of breaking up a string into words, phrases, or symbols. \n    - Tokenize a sentence into words.\n    - `\"mike is here\"` becomes the iterable  `['mike', 'is', 'here']`\n- **Parsing** is the process of extracting meaning from a string. \n    - Parse text to a numerical value or date.\n    - `int('45')` becomes `45`\n\n::: {#661bc631 .cell tags='[]' execution_count=14}\n``` {.python .cell-code}\n# tokenize with split()\n# parse with int(), or float()\n\ntext = \"30 40 90 10\"\ntokens = text.split()\nnumbers = [int(t) for t in tokens]\ntotal = sum(numbers)\nprint(total)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n170\n```\n:::\n:::\n\n\n::: {#7cc5e858 .cell tags='[]' execution_count=15}\n``` {.python .cell-code}\n# What you split on is called the delimiter:\ntext = \"name, age, phone, gpa\"\nitems = [ x.upper().strip() for x in text.split(',') ]\nprint(items)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['NAME', 'AGE', 'PHONE', 'GPA']\n```\n:::\n:::\n\n\n# Files\n\n## Files == Persistence\n\n- Files add a **Persistence Layer** to our computing environment where we can store our data  **after the program completes**. \n- **Think: Saving a game's progress or saving your work!**\n- When our program **Stores** data, we open the file for **writing**.\n- When our program **Reads** data, we open the file for **reading**.\n- To read or write a file we must first **open** it, which gives us a special variable called a **file handle**. \n- We then use the **file handle** to read or write from the file.\n- The **read()** function reads from the **write()** function writes to the file through the file handle. \n\n### Reading from a file\n\n::: {#5257b62a .cell tags='[]' execution_count=16}\n``` {.python .cell-code}\nfilename = \"data/sample.txt\"\nprint(\"=== All at once ===\")\nwith open(filename, 'r') as handle:\n    contents = handle.read()\n    print(contents)\n\nprint(\"=== A Line at a time ===\")\ni = 1\nwith open(filename, 'r') as handle:\n    for line in handle.readlines():\n        print(i, line.strip())\n        i += 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n=== All at once ===\nThis\nIs\nA\nSample\n=== A Line at a time ===\n1 This\n2 Is\n3 A\n4 Sample\n```\n:::\n:::\n\n\n### Writing to a file\n\n::: {#1649ecf0 .cell tags='[]' execution_count=17}\n``` {.python .cell-code}\nfilename = \"data/demo.txt\"\nprint(\"=== Create file and write to it ===\")\nwith open(filename, \"w\") as f:\n    f.write(\"message!\\n\")\n\nprint(\"=== Append (add to end) of existing file ===\")\nwith open(filename, \"a\") as f:\n    f.write(\"message # 2!\\n\")\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n=== Create file and write to it ===\n=== Append (add to end) of existing file ===\n```\n:::\n:::\n\n\n::: {#2ed9ced6 .cell execution_count=18}\n``` {.python .cell-code}\n%%bash\n# switch to bash interpreter\ncat data/demo.txt\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmessage!\nmessage # 2!\n```\n:::\n:::\n\n\n### Handling missing files\n\n::: {#906c3ae2 .cell tags='[]' execution_count=19}\n``` {.python .cell-code}\n# Try / Except to handle FileNotFound\ntry:\n    file = 'data/data.txt'\n    with open(file,'r') as f:\n        print( f.read() )\nexcept FileNotFoundError:\n    print(f\"{file} was not found!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndata/data.txt was not found!\n```\n:::\n:::\n\n\n## JSON and Python Dictionaries\n\n- [JSON](https://www.w3schools.com/whatis/whatis_json.asp) (**JavaScript Object Notation**) is a standard, human-readable  data format. It's a popular format for data on the web.\n- JSON can be easily converted to lists of dictionaries using Python's **json** module.\n- Transferring a JSON string to Python is known as **de-serializing**. \n- Transferring Python to a JSON string is known as **serializing**. \n- **<font color='red'>This is easy to do in Python but challenging to do in most other languages.</font>**\n\n### Serialization\n\n::: {#146f59e8 .cell tags='[]' execution_count=20}\n``` {.python .cell-code}\n# Serialize a python object as json\nimport json\ngrades = { 'CHE101' : [100, 80, 70], 'IST195' : [100, 80, 100] }\nwith open(\"data/grades.json\", \"w\") as f:\n    json.dump(grades, f, indent=4) # write grades to file as JSON\n```\n:::\n\n\n::: {#ca266563 .cell execution_count=21}\n``` {.python .cell-code}\n%%bash\n# switch to bash interpreter\ncat data/grades.json\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\n    \"CHE101\": [\n        100,\n        80,\n        70\n    ],\n    \"IST195\": [\n        100,\n        80,\n        100\n    ]\n}\n```\n:::\n:::\n\n\n### Deserialization\n\n::: {#dadd0911 .cell tags='[]' execution_count=22}\n``` {.python .cell-code}\n# de-serialize some json\nfile = \"data/stocks.json\"\nwith open(file, \"r\") as f:\n    stocks = json.load(f)\n    \n# stocks is a python object\n# Deserialized from text!\nfor stock in stocks:\n    print(stock['symbol'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAAPL\nAMZN\nFB\nGOOG\nIBM\nMSFT\nNET\nNFLX\nTSLA\nTWTR\n```\n:::\n:::\n\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 3.3\n\nwrite a program to read in a string of students and gpas in one input statement like this:\n\n`mike 3.4, noel 3.2, obby 3.5, peta 3.4`\n\nand write out JSON like this:\n\n```\n[\n    { \"name\" : \"mike\", \"gpa\" : 3.4 },\n    { \"name\" : \"noel\", \"gpa\" : 3.2 },\n    { \"name\" : \"obby\", \"gpa\" : 3.5 },\n    { \"name\" : \"peta\", \"gpa\" : 3.4 }\n]\n```\n\nSuggested approach:\n\n1. input text\n2. split on \",\" from the text\n3. for each student:\n    - split the student into name and gpa\n    - parse the gpa so its a float\n    - add the name and gpa to the list as a dictionary\n4. write the list to students.json as JSON\n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n::: {#f8875a2c .cell execution_count=23}\n``` {.python .cell-code}\nimport json \ntext = input(\"Enter names and grades: \")\nstudents = []\nfor student in text.split(\",\"):\n    name, gpa = student.strip().split()\n    gpa = float(gpa)\n    students.append({ \"name\": name, \"gpa\": gpa })\nwith open (\"students.json\", \"w\") as f:\n    json.dump(students, f)\n```\n:::\n\n\n:::\n::::\n\n",
    "supporting": [
      "python-3_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}