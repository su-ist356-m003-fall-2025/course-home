{
  "hash": "6349b02effbe506a9dcf991dbe215500",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"1. Introduction to NumPy\"\njupyter: python3\n---\n\nData manipulation in Python is nearly synonymous with NumPy array manipulation: even tools like Pandas are built around the NumPy array.\nNumpy arrays can be thought of as **mathematical vectors** and behave correspondingly; contrary to Python lists, which are a container that stores arbitrary objects.\n\n\n## Python list recap\n\nWe saw previously that arrays allow us to store a series of values in a single variable. For example:\n\n::: {#d896f2c9 .cell execution_count=1}\n``` {.python .cell-code}\nlistnumbers = [1, 2, 3]\nprint(listnumbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nNotably, in Python, a list can contain objects that are not of the same data type. For example:\n\n::: {#8d615d9f .cell execution_count=2}\n``` {.python .cell-code}\nlist1 = [1, \"string\", {'a':1}, [[1, 3], set()]]  # arbitrary objects\nprint(list1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 'string', {'a': 1}, [[1, 3], set()]]\n```\n:::\n:::\n\n\nAdding two lists concatenates them, there is no mathematical operation: adding two containers that contain arbitrary objects means \"combining\" them.\n\n::: {#88d132a9 .cell execution_count=3}\n``` {.python .cell-code}\nlistadd = list1 + listnumbers\nprint(listadd)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 'string', {'a': 1}, [[1, 3], set()], 1, 2, 3]\n```\n:::\n:::\n\n\nBeing able to store multiple data types in a single list can be convenient. However, Python lists can be cumbersome to work with when doing mathematical operations, and for more complex and multi-dimensional data. They are also relatively slow to process. For example, say we wanted to add two large lists of values together. We would need to do the following:\n\n::: {#2378ed65 .cell execution_count=4}\n``` {.python .cell-code}\n# create large list a\na = range(1000000)\nb = range(1000000)\nadded_list = [ai+bi for ai, bi in zip(a, b)]\n```\n:::\n\n\nLet's time how long it took to do that last line. For that, we can use the `%timeit` magic command in a jupyter notebook:\n\n::: {#ded01f22 .cell execution_count=5}\n``` {.python .cell-code}\n%timeit added_list = [ai+bi for ai, bi in zip(a, b)]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n94.3 ms ± 819 μs per loop (mean ± std. dev. of 7 runs, 10 loops each)\n```\n:::\n:::\n\n\nWhile this may seem fast in human time, it's quite slow computationally wise. If you had multiple operations like this it would quickly add up. As we will see below, it's possible to do array operations like this much more quickly using NumPy.\n\n## NumPy arrays\n\nFor much faster, easier manipulation of numerical arrays, we use [NumPy](https://numpy.org/). What is NumPy? A good summary is provided by Claude AI:\n\n> NumPy is a fundamental Python library for scientific computing that provides support for large, multi-dimensional arrays and matrices. It offers a comprehensive collection of mathematical functions to operate on these arrays efficiently, with operations implemented in C for high performance. NumPy serves as the foundation for most other scientific Python libraries like pandas, scikit-learn, and matplotlib, making it essential for data science, machine learning, and numerical analysis workflows.\n\nLet's see how to do some basic array operations with numpy. First, if you have not done so, you'll need to install numpy into your conda environment. To do so, in a terminal, activate your conda environment, then either run:\n\n```bash\npip install numpy\n```\nor\n```bash\nconda install -y -c conda-forge numpy\n```\n\nWe can now import numpy:\n\n::: {#40ef61c9 .cell execution_count=6}\n``` {.python .cell-code}\nimport numpy as np\n```\n:::\n\n\n### NumPy array creation\nThere are multiple ways to create an array using numpy. Some examples:\n\n::: {#86d980ad .cell execution_count=7}\n``` {.python .cell-code}\n# from a Python list:\narrnumbers = np.array(listnumbers)\nprint(\"arrnumbers:\", arrnumbers)\n\n# manually creating it:\narrnumbers2 = np.array([5, 3, 42])\nprint(\"arrnumbers2:\", arrnumbers2)\n\n# from a range of values (compare to range above):\narrnumbers3 = np.arange(1000000)\nprint(\"arrnumbers3:\", arrnumbers3)\n\n# an array of values linearlly spaced between two endpoints:\narrlinspace = np.linspace(0, 10, 5)  # 5 values equally spaced between 0 and 10\nprint(\"arrlinspace:\", arrlinspace)\n\n# an array of zeros:\narrzeros = np.zeros(4)\nprint(\"arrzeros:\", arrzeros)\n\n# an array of ones:\narrones = np.ones(4)\nprint(\"arrones:\", arrones)\n\n# an empty array (values will be whatever is in memory at the time):\narrempty = np.empty(4)\nprint(\"arrempty:\", arrempty)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narrnumbers: [1 2 3]\narrnumbers2: [ 5  3 42]\narrnumbers3: [     0      1      2 ... 999997 999998 999999]\narrlinspace: [ 0.   2.5  5.   7.5 10. ]\narrzeros: [0. 0. 0. 0.]\narrones: [1. 1. 1. 1.]\narrempty: [1. 1. 1. 1.]\n```\n:::\n:::\n\n\nNumPy arrays can have multiple dimensions:\n\n::: {#46a6e8fa .cell execution_count=8}\n``` {.python .cell-code}\narr2d = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2d)\n\n# we can get the number of dimensions with .ndim:\nprint(\"arr2d.ndim:\", arr2d.ndim)\n\n# or the shape with .shape:\nprint(\"arr2d.shape:\", arr2d.shape) # returns the number of rows and columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]]\narr2d.ndim: 2\narr2d.shape: (2, 3)\n```\n:::\n:::\n\n\nMany array constructor functions take a `shape` argument to create a mult-dimensional array:\n\n::: {#f97cef3d .cell execution_count=9}\n``` {.python .cell-code}\nzeros2d = np.zeros((3, 4))  # 3 rows, 4 columns\nprint(\"zeros2d:\\n\", zeros2d)\n\nones3d = np.ones((2, 3, 4))  # 2 blocks, 3 rows, 4 columns\nprint(\"ones3d:\\n\", ones3d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nzeros2d:\n [[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\nones3d:\n [[[1. 1. 1. 1.]\n  [1. 1. 1. 1.]\n  [1. 1. 1. 1.]]\n\n [[1. 1. 1. 1.]\n  [1. 1. 1. 1.]\n  [1. 1. 1. 1.]]]\n```\n:::\n:::\n\n\nOr, we can reshape a current array:\n\n::: {#2b0bc7b9 .cell execution_count=10}\n``` {.python .cell-code}\narrnumbers2d = arrnumbers3.reshape(1000, 1000)  # 1000 rows, 1000 columns\nprint(\"arrnumbers3.shape:\", arrnumbers3.shape)\nprint(\"arrnumbers3:\\n\", arrnumbers3)\n\nprint(\"arrnumbers2d.shape:\", arrnumbers2d.shape)\nprint(\"arrnumbers2d:\\n\", arrnumbers2d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narrnumbers3.shape: (1000000,)\narrnumbers3:\n [     0      1      2 ... 999997 999998 999999]\narrnumbers2d.shape: (1000, 1000)\narrnumbers2d:\n [[     0      1      2 ...    997    998    999]\n [  1000   1001   1002 ...   1997   1998   1999]\n [  2000   2001   2002 ...   2997   2998   2999]\n ...\n [997000 997001 997002 ... 997997 997998 997999]\n [998000 998001 998002 ... 998997 998998 998999]\n [999000 999001 999002 ... 999997 999998 999999]]\n```\n:::\n:::\n\n\n### Array slicing\nSimilar to Python lists, we can access elements of a list using braces and indices. The syntax is:\n```python\narr[start:end:step]\n```\nSome examples:\n\n::: {#8fdc7db7 .cell execution_count=11}\n``` {.python .cell-code}\n# print a single element in arrnumbers:\nprint(arrnumbers[0]) # first element\nprint(arrnumbers[1]) # second element\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n```\n:::\n:::\n\n\n::: {#136f0587 .cell execution_count=12}\n``` {.python .cell-code}\n# print a range of elements in arrnumbers:\nprint('arrnumbers[0:2]:', arrnumbers[0:2])\n\n# equivalently:\nprint('arrnumbers[:2]:', arrnumbers[:2])  # start is 0 by default\n\n# or to print from an index to the end:\nprint('arrnumbers[1:]:', arrnumbers[1:])  # goes to the end by default\n\n# or to print all numbers:\nprint('arrnumbers[:]:', arrnumbers[:])  # start and end are default\n\n# print every second element:\nprint('arrnumbers[::2]:', arrnumbers[::2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narrnumbers[0:2]: [1 2]\narrnumbers[:2]: [1 2]\narrnumbers[1:]: [2 3]\narrnumbers[:]: [1 2 3]\narrnumbers[::2]: [1 3]\n```\n:::\n:::\n\n\nNegative indices can be used to slice starting from the end, and to reverse order. For example:\n\n::: {#08b95724 .cell execution_count=13}\n``` {.python .cell-code}\nprint('arrnumbers[-2:]', arrnumbers[-2:])  # print the last two elements\nprint('arrnumbers[::-1]', arrnumbers[::-1])  # print all elements in reverse order\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narrnumbers[-2:] [2 3]\narrnumbers[::-1] [3 2 1]\n```\n:::\n:::\n\n\nFor multi-dimensional arrays, the same rules apply, you just separate the indexing for each dimension by commas. For example:\n\n::: {#b99efdf8 .cell execution_count=14}\n``` {.python .cell-code}\nprint(\"arr2d:\\n\", arr2d)\nprint(\"arr2d[0, 0]:\", arr2d[0, 0])  # first row, first column\nprint(\"arr2d[:, 0]:\", arr2d[:, 0])  # all rows, first column\nprint(\"arr2d[0, :]:\", arr2d[0, :])  # first row, all columns\nprint(\"arr2d[0:2, 1:3]:\\n\", arr2d[0:2, 1:3])  # first two rows, columns 1 and 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narr2d:\n [[1 2 3]\n [4 5 6]]\narr2d[0, 0]: 1\narr2d[:, 0]: [1 4]\narr2d[0, :]: [1 2 3]\narr2d[0:2, 1:3]:\n [[2 3]\n [5 6]]\n```\n:::\n:::\n\n\n### Subarrays as no-copy views\n\nOne important–and extremely useful–thing to know about array slices is that they return *views* rather than *copies* of the array data.\nThis is one area in which NumPy array slicing differs from Python list slicing: in lists, slices will be copies.\nConsider our two-dimensional array from before:\n\n::: {#6a076630 .cell execution_count=15}\n``` {.python .cell-code}\nprint(arr2d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]]\n```\n:::\n:::\n\n\nLet's extract a $2 \\times 2$ subarray from this:\n\n::: {#0606e415 .cell execution_count=16}\n``` {.python .cell-code}\narr2d_sub = arr2d[:2, :2]\nprint(arr2d_sub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2]\n [4 5]]\n```\n:::\n:::\n\n\nNow if we modify this subarray, we'll see that the original array is changed! Observe:\n\n::: {#7df94cc3 .cell execution_count=17}\n``` {.python .cell-code}\narr2d_sub[0, 0] = 99\nprint(arr2d_sub)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[99  2]\n [ 4  5]]\n```\n:::\n:::\n\n\n::: {#423e2f95 .cell execution_count=18}\n``` {.python .cell-code}\nprint(arr2d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[99  2  3]\n [ 4  5  6]]\n```\n:::\n:::\n\n\nThis default behavior is actually quite useful: it means that when we work with large datasets, we can access and process pieces of these datasets without the need to copy the underlying data buffer.\n\n### Creating copies of arrays\n\nDespite the nice features of array views, it is sometimes useful to instead explicitly copy the data within an array or a subarray. This can be most easily done with the ``copy()`` method:\n\n::: {#c63857cf .cell execution_count=19}\n``` {.python .cell-code}\narr2d_sub_copy = arr2d[:2, :2].copy()\nprint(arr2d_sub_copy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[99  2]\n [ 4  5]]\n```\n:::\n:::\n\n\nIf we now modify this subarray, the original array is not touched:\n\n::: {#a71adf6f .cell execution_count=20}\n``` {.python .cell-code}\narr2d_sub_copy[0, 0] = 42\nprint(arr2d_sub_copy)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[42  2]\n [ 4  5]]\n```\n:::\n:::\n\n\n::: {#033623e4 .cell execution_count=21}\n``` {.python .cell-code}\nprint(arr2d)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[99  2  3]\n [ 4  5  6]]\n```\n:::\n:::\n\n\n### Boolean slicing\nYou can use boolean expressions to retrieve certain values in an array. For example:\n\n::: {#427b4619 .cell execution_count=22}\n``` {.python .cell-code}\n# print all the values in arrnumbers2 greater than 4:\nprint(\"arrnumbers:\\n\", arrnumbers2)\nprint(\"arrnumbers > 5:\\n\", arrnumbers2[arrnumbers2 > 4])  # boolean array\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narrnumbers:\n [ 5  3 42]\narrnumbers > 5:\n [ 5 42]\n```\n:::\n:::\n\n\nWhat's actually happening here is you're first creating a *boolean* array. This is an array in which each element is either True or False. In this case, `arrnumbers2 > 4` is creating an array indicating which indices in `arrnumbers2` are greater than 4. Passing the boolean array as an index then pulls out those values. We can see this if we break it into two steps:\n\n::: {#29fb1c31 .cell execution_count=23}\n``` {.python .cell-code}\nmask = arrnumbers2 > 4\nprint(\"mask:\\n\", mask)\nprint(\"arrnumbers2[mask]:\\n\", arrnumbers2[mask])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmask:\n [ True False  True]\narrnumbers2[mask]:\n [ 5 42]\n```\n:::\n:::\n\n\n## Data types\nA key difference between NumPy arrays and Python arrays is that **the data in a NumPy array must all be of the same type**. You can get the data type of the values in an array using `.dtype`. For example:\n\n::: {#2e112c65 .cell execution_count=24}\n``` {.python .cell-code}\nprint('arrnumbers:', arrnumbers)\nprint('arrnumbers.dtype:', arrnumbers.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narrnumbers: [1 2 3]\narrnumbers.dtype: int64\n```\n:::\n:::\n\n\n::: {#581711be .cell execution_count=25}\n``` {.python .cell-code}\nprint('arrones:', arrones)\nprint('arrones.dtype:', arrones.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\narrones: [1. 1. 1. 1.]\narrones.dtype: float64\n```\n:::\n:::\n\n\n::: {#2f33d60f .cell execution_count=26}\n``` {.python .cell-code}\nprint('mask:', mask)\nprint('mask.dtype:', mask.dtype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmask: [ True False  True]\nmask.dtype: bool\n```\n:::\n:::\n\n\nIf you try to create an array with different data types, numpy will automatically cast them to all be the same. For example:\n\n::: {#c1b68c63 .cell execution_count=27}\n``` {.python .cell-code}\nmixed = np.array([1, 2.0, 3, 4.8, True, False])  # ints, floats, bools\nprint(\"mixed:\", mixed)\nprint(\"mixed.dtype:\", mixed.dtype)  # everything cast to float (note that True -> 1, False -> 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmixed: [1.  2.  3.  4.8 1.  0. ]\nmixed.dtype: float64\n```\n:::\n:::\n\n\nYou can cast an array to a different type using `.astype`. This will create a copy of the array with values cast to the type you specified. For example:\n\n::: {#aec31c49 .cell execution_count=28}\n``` {.python .cell-code}\nmixedint = mixed.astype(int)  # cast to int\nprint(\"mixedint:\", mixedint)\nprint(\"mixedint.dtype:\", mixedint.dtype)  # everything cast to int\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nmixedint: [1 2 3 4 1 0]\nmixedint.dtype: int64\n```\n:::\n:::\n\n\n## Array operations\n\nOne of the most useful aspects about NumPy arrays is they allow you to perform mathematical operations on the all the elements in the list using the same syntax you would for single variables. For example, we can add all the values in one array to another by doing:\n\n::: {#6eef4f10 .cell execution_count=29}\n``` {.python .cell-code}\na = np.arange(1000000)\nb = np.arange(1000000)\nc = a + b  # add element-wise\nprint(\"c:\", c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nc: [      0       2       4 ... 1999994 1999996 1999998]\n```\n:::\n:::\n\n\nCompare that to the way we had to add two Python lists together above. Note that if `a` and `b` were Python lists `a+b` concatenates them together (i.e., appends the values of `b` on to the end of `a`) where as if `a` and `b` are Numpy arrays, the values are added together element-wise.\n\nAside from being easier to write, NumPy array operations are also much faster than Python operations. Let's time how long it took to create `c`:\n\n::: {#0fb8cb64 .cell execution_count=30}\n``` {.python .cell-code}\n%timeit c = a + b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n381 μs ± 20.5 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n```\n:::\n:::\n\n\nCompare to what we got when we did the same thing with Python lists above. It's about 100 times faster!\n\n### More advanced math operations\nNumpy comes with a large number of math functions built-in, which we can run on NumPy arrays. For example:\n\n::: {#53fecdb1 .cell execution_count=31}\n``` {.python .cell-code}\n# take the sine of every element in a:\nprint(np.sin(a))\n\n# sum up all the values in a:\nprint(np.sum(a))\n\n# take the average of all the values in a:\nprint(np.mean(a))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 0.          0.84147098  0.90929743 ...  0.21429647 -0.70613761\n -0.97735203]\n499999500000\n499999.5\n```\n:::\n:::\n\n\nSome operations can also be executed as methods on the array. For example:\n\n::: {#ee279df5 .cell execution_count=32}\n``` {.python .cell-code}\n# sum up all the values in a:\nprint(a.sum())  \n\n# take the average of all the values in a:\nprint(a.mean())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n499999500000\n499999.5\n```\n:::\n:::\n\n\nNote that this doesn't work with the sine function, however:\n\n::: {#13d34fb9 .cell execution_count=33}\n``` {.python .cell-code}\na.sin()\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">AttributeError</span>                            Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[33]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span class=\"ansi-yellow-bg\">a</span><span class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">sin</span>()\n\n<span class=\"ansi-red-fg\">AttributeError</span>: 'numpy.ndarray' object has no attribute 'sin'</pre>\n```\n:::\n\n:::\n:::\n\n\nIn VS Code, you can see all the operations you can call as methods of the array by typing the array name + `.`; e.g., `a.`. That will show a drop-down list that you can cycle through.\n\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 1.1\n\nLet's illustrate the speed and simplicity of NumPy vs native Python lists.\n\n1.  Create a Python array that has 100,000 values equally spaced between 0 and `2*pi` (`pi = 3.141592653589793`).\n\n1.  Calculate the average of the cosine of every value in the Python array. For the `cos` function, you will need to import the `math` module.\n\n1.  Repeat steps 1 and 2, but using purely NumPy arrays and functions. You should be able to do step 2 in a single line of code. Note that NumPy has an in-built `pi` value (`np.pi`).\n\n1.  Time how long it takes the computer to do Step 2. Compare how long that takes when you use NumPy. When doing the comparison, just time the math operation step, not the array creation. Which is faster? *Hint*: for timing the Python version, you'll need to use `%%timeit` rather than `%timeit`, as the Python version will require multiple lines of code. Put all the lines in a single cell in your notebook, and put `%%timeit` at the top to time the entire cell, rather than just a single line.\n\n1.  Which is computationally faster? By what factor?\n\n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n1. To create the Python array:\n\n::: {#5d427166 .cell execution_count=34}\n``` {.python .cell-code}\nxsize = 100000\nx = [xi*2*np.pi/xsize for xi in range(xsize)]\n```\n:::\n\n\n2.  Evaluation:\n\n::: {#534d1982 .cell execution_count=35}\n``` {.python .cell-code}\nimport math\ny = [math.cos(xi) for xi in x]\nsum(y)/len(y)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n-3.8771274778262895e-17\n```\n:::\n:::\n\n\n3. Same, with numpy:\n\n::: {#d37d6978 .cell execution_count=36}\n``` {.python .cell-code}\nimport numpy as np\n# create the array\nx = np.linspace(0, 2*np.pi, xsize)\n# take the average of the cosine of the values\nnp.cos(x).mean()\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\nnp.float64(9.99999999994543e-06)\n```\n:::\n:::\n\n\n4. Python timing, in a Jupyter cell:\n\n::: {#99a480c6 .cell execution_count=37}\n``` {.python .cell-code}\n%%timeit\ny = [math.cos(xi) for xi in x]\nsum(y)/len(y)\n```\n:::\n\n\nNumpy:\n\n::: {#73e9850e .cell execution_count=38}\n``` {.python .cell-code}\n%timeit np.cos(x).mean()\n```\n:::\n\n\nYou should get that the numpy version is faster, by a factor of 10-100.\n\n:::\n::::\n\n",
    "supporting": [
      "numpy_basics_files"
    ],
    "filters": [],
    "includes": {}
  }
}