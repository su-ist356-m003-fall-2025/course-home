{
  "hash": "ffd272851737f896776ec1eaa2d81b10",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: '2. Posting with REST API and caching results'\njupyter: python3\n---\n\n\n## HTTP Methods beyond GET\n\nSo far we have only seen GET requests. But there are other HTTP methods that are used to perform different operations  such as:\n\n- POST: Create a new resource\n- PUT: Update an existing resource\n- DELETE: Delete a resource\n\nFrom the perspective of `requests` these behave the same as a GET. The only subtle difference is that you can pass a `data` parameter when there are large payloads which cannot fit on the URL.\n\n## Example of a POST request\n\nLet's do an example with the Azure sentiment API from the IoT Portal. This REST API requires the text to analyze, and will return the sentiment or \"mood\" of the text.  Since there can be a substantial amount of text, the API requires the POST method, and the data to be sent in the body of the request.\n\n::: {.callout-note}\nRecall that to run the commands below, you will need to get your API key from https://cent.ischool-iot.net. Log in, then copy the API key given there. In the code blocks below, replace the `YOURAPIKEYHERE` with what you copied.\n:::\n\nFirst, try it out in the [IoT portal](https://cent.ischool-iot.net/doc) by clicking on the `/api/azure/sentiment` drop-down menu, then clicking \"Execute\". For the text, enter: \"I love IST356. It is the best course I've ever taken.\"\n\nNow let's convert the `curl` command the portal gave to Python `requests` code. \n\n::: {#921e15bc .cell execution_count=1}\n``` {.python .cell-code}\nimport requests\n\n'''\ncurl -X 'POST' \\\n  'https://cent.ischool-iot.net/api/azure/sentiment' \\\n  -H 'accept: application/json' \\\n  -H 'X-API-KEY: APIKEY' \\\n  -H 'Content-Type: application/x-www-form-urlencoded' \\\n  -d 'text=I%20love%20IST356.%20It%20is%20the%20best%20course%20I'\\''ve%20ever%20taken.'\n'''\n\napikey = 'YOURAPIKEYHERE'\nurl = 'https://cent.ischool-iot.net/api/azure/sentiment'\nheaders = {\n    'accept': 'application/json',\n    'X-API-KEY': apikey,\n    'Content-Type': 'application/x-www-form-urlencoded'\n}\ndata = {\n    \"text\": \"I love IST356. It is the best course I've ever taken.\"\n}\nresponse = requests.post(url, headers=headers, data=data)\nresponse.raise_for_status()\nresults = response.json()\nsentiment = results['results']['documents'][0]['sentiment']\nprint(sentiment)\n```\n:::\n\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 2.1\n\nFor this challenge, use Azure entity recognition API to extract entities from the following text.\n\n`The Philadelphia Eagles are a better team than the New York Giants this year. The Giants have lost 6 games and are at the bottom of the NFC East, while the Eagles are at the top of the division.`\n\nUsing the API output, print each extracted entity and its type.\n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n::: {#5a4376b6 .cell execution_count=2}\n``` {.python .cell-code}\nimport requests\n\napikey = 'YOURAPIKEYHERE'\nurl = \"https://cent.ischool-iot.net/api/azure/entityrecognition\"\nheaders = {\n    \"accept\": \"application/json\",\n    \"X-API-KEY\": apikey,\n    \"Content-Type\": \"application/x-www-form-urlencoded\",\n}\ndata = {\n    \"text\": \"The Philadelphia Eagles are a better team than the New York Giants this year. The Giants have lost 6 games and are at the bottom of the NFC East, while the Eagles are at the top of the division.\"\n}\nresponse = requests.post(url, headers=headers, data=data)\nresponse.raise_for_status()\ndata = response.json()\nfor d in data['results']['documents'][0]['entities']:\n    print(d['text'], d['category'])\n```\n:::\n\n\n:::\n::::\n\n\n## Caching Strategies\n\nWhen you are making a lot of requests to an API, it is a good idea to cache the results. We don't want to make the same request over and over again if we don't have to as this can effect our rate limits and thus our pricing.\n\nCaching can be done in a number of ways. The simplest method is a Python dictionary where the key is the request and the value is the response. \n\nThe caching strategy looks like this:\n\n1. Check if the request is in the cache\n\n2. If it is, we have a CACHE hit: return the response from the cache.\n\n3. If it is not, call the API to get the response. Add it to the cache for the future.\n\n\nYou can do caching yourself by using Python dictionaries. However, if you want to cache results across sessions then you will need to save the dictionary to disk so it can be loaded in the future. You can use the Python `pickle` library to do that.\n\nHere's an example with the Google Geocoding API on the IoT Portal:\n\n::: {#6677a75b .cell execution_count=3}\n``` {.python .cell-code}\nimport os\nimport pickle\n\npickle_file = 'geocode_cache.pkl'\nif os.path.exists(pickle_file):\n    with open(pickle_file, 'rb') as fp:\n        cache = pickle.load(fp)\nelse:\n    cache = {}\n\nlocation = 'Syracuse, NY'\ncache_key = location.lower()\n\nfor i in range(3):\n    try:\n        geo = cache[cache_key]\n        print('Used cache')\n    except KeyError:\n        print('Making request')\n        url = 'https://cent.ischool-iot.net/api/google/geocode'\n        headers = { 'X-API-KEY': apikey }\n        params = {'location': location}\n        response = requests.get(url, params=params, headers=headers)\n        response.raise_for_status()\n        geo = response.json()\n        # cache\n        cache[cache_key] = geo\n    print(geo['results'][0]['geometry']['location'])\n\n# save cache to disk for future use\nwith open(pickle_file, 'wb') as fp:\n    pickle.dump(cache, fp)\n```\n:::\n\n\nThe first time you run that, you will see the request is only made the first time through the loop. If you run that code again, even the first time will come from the cache, since it will read it from disk.\n\n### Using `requests-cache`\n\nThe [requests-cache](https://requests-cache.readthedocs.io/en/stable/index.html) Python package makes caching easy for you. It takes care of caching things to disk for you and loading them. It also lets you do things like set expiration times on cache entries, so you don't end up using stagnant data.\n\n\n::: {.callout-note}\n`requests-cache` is not in the Python standard library, so you'll need to install it. As always, you can do that by:\n\n1. In a terminal, activate your `ist356` conda environment.\n\n2. Run `pip install requests-cache`.\n:::\n\nHere's the above example again, but using `requests-cache`:\n\n::: {#0a4d7c68 .cell execution_count=4}\n``` {.python .cell-code}\nimport requests_cache\n\nlocation = 'Syracuse, NY'\n\n# start up a cached session. We need to explicitly set the allowable_methods\n# for it to cache posts\nrs = requests_cache.CachedSession(cache_name='geocode', allowable_methods=('GET', 'POST', 'HEAD')) \n# If you want to clear the cache:\n#rs.cache.clear()\n\nfor i in range(3):\n    url = 'https://cent.ischool-iot.net/api/google/geocode'\n    headers = { 'X-API-KEY': apikey }\n    params = {'location': location}\n    response = rs.get(url, params=params, headers=headers)\n    response.raise_for_status()\n    if response.from_cache:\n        print('Used cache')\n    else:\n        print('Made request')\n    geo = response.json()\n    print(geo['results'][0]['geometry']['location'])\n```\n:::\n\n\nThat's it! If you rerun the code above, you'll find that it will use the cache the first time through. To clear the cache, uncomment the `rs.cache.clear()` line.\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 2.2\n\nSend requests to the Azure sentiment API for each one of the sentences below. Use the `requests_cache` module to cache responses. For each of the following sentences, output the sentence, the sentiment, and if the results came from the API or the cache.\n\n::: {#f7d8cc2f .cell execution_count=5}\n``` {.python .cell-code}\ntexts = [\n    \"I love the Syracuse Orange.\", \n    \"I hate the Duke Blue Devils.\",\n    \"I love the Syracuse Orange.\", \n    \"I don't like the Duke Blue Devils.\"\n]\n```\n:::\n\n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n::: {#0217946e .cell execution_count=6}\n``` {.python .cell-code}\nimport requests_cache\n\ntexts = [\n    \"I love the Syracuse Orange.\", \n    \"I hate the Duke Blue Devils.\",\n    \"I love the Syracuse Orange.\", \n    \"I don't like the Duke Blue Devils.\"\n]\n\nrs = requests_cache.CachedSession(cache_name='sentiment', allowable_methods=('GET', 'POST', 'HEAD')) \nheaders = { 'x-api-key': apikey }\nurl = \"https://cent.ischool-iot.net/api/azure/sentiment\"\nfor text in texts:\n    data = {'text': text}\n    response = rs.post(url, headers=headers, data=data)\n    response.raise_for_status()\n    if response.from_cache:\n        from_cache = \"CACHED\"\n    else:\n        from_cache = \"NOT CACHED\"\n    results = response.json()\n    sentiment = results['results']['documents'][0]['sentiment']\n    print(text, sentiment, from_cache)\n```\n:::\n\n\n:::\n::::\n\n",
    "supporting": [
      "webapi-2_files"
    ],
    "filters": [],
    "includes": {}
  }
}