{
  "hash": "fd64ebb8ccf7e0347578c086fed28e4d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: '3. Creating your own APIs with FastAPI'\njupyter: python3\n---\n\n::: {.callout-important}\nIn order to do this tutorial, you will need to install fastapi. To do that, open a terminal, activate your `ist356` conda environment, then run:\n```{bash}\npip install \"fastapi[standard]\"\n```\n**Make sure you put `fastapi[standard]` in quotes, as shown here.** \n:::\n\n\n## API vs Module \n\nYou might be asking why host an API versus just writing a module? After all they have similar functionality of sharing and interacting with code and data.\n\nThere are some key differences between an API and a module:\n\n1. You can hide the implementation details of your code with an API. Unlike a module, people only see the interface, not way to code was implemented.\n2. An API can be accessed over the internet, while a module is typically used locally.\n3. API's work across different programming languages, while modules are either restricted to the language they were written in (in our case, Python), or need to be wrapped with an intermediate (e.g., Cython for C->Python).\n4. Since an API is run remotely, it can be run on large high performance computing clusters, whereas modules are typically limited to whatever machine your are running on. This is particularly important for LLMs, which need large, power intensive GPU resources to work.\n\n## Fast API\n\n[https://fastapi.tiangolo.com/](https://fastapi.tiangolo.com/)\n\n- Fast API is an easy-to-learn Python framework for building APIs. \n- It has a lot of features that make it a great choice for building APIs.\n- We will focus on a few simple functions so that you can understand how it works.\n\n\n# Fast API Features\n\n- Live edit similar to Streamlit. You can edit your code and see the changes in real time.\n- Highly opinionated. It has a lot of features that are built in but you must do it the \"FastAPI way.\"\n- Easy to understand the code. \n- Auto-generates API documentation Swagger UI.\n\nHere's a simple example that provides a GET API that returns a \"Hello World\" message formatted as JSON:\n\n::: {#0d86ea3f .cell execution_count=1}\n``` {.python .cell-code}\nfrom fastapi import FastAPI\n\napp = FastAPI()  # Create a FastAPI instance\n\n@app.get(\"/\")    # Define a route\ndef root():      # Define a function that will be called when the route is requested\n    return {\"message\": \"Hello World\"} # Serializes to JSON automatically\n```\n:::\n\n\nTo use this, save this to a file (let's call it `helloapi.py`. Then, from the command line, run:\n\n```{bash}\npython -m fastapi dev helloapi.py\n```\n\nWhen you run it, you will it say, `Server started at ...`, followed by a URL in the form of an IP address. Copy that URL. You can then interact with your API with the following (you can run this in a Jupyter notebook):\n\n::: {#b76ca1e7 .cell execution_count=2}\n``` {.python .cell-code}\nimport requests\n\nurl = 'REPLACE_WITH_COPIED_URL'\nresponse = requests.get(url)\nresponse.raise_for_status()\nprint(response.json())\n```\n:::\n\n\nFastAPI also provides automatically generated documentation. You can view that by opening the URL provided `/docs` in your browser. For instance, if the URL was `http://127.0.0.1:8000` then you would open `http://127.0.0.1:8000/docs` in your browser. Does the format look familiar? It's the same as the IoT portal! (Now you know how that was built.)\n\n\n## Query String Path, and Header Parameters\n\nFast API makes it easy to add parameters to your API. \n\n- Python type hints are used to define the type of the parameter (int, str, etc.). *If not type hints are provided, FastAPI will assume the input is string. This can lead to unintended consequences!*\n- The `Query()` function is used to define a query parameter\n- The `Header()` function is used to define a header parameter\n- Path parameters are defined by including the parameter in the URL path\n\nHere's an example:\n\n::: {#921c4d27 .cell execution_count=3}\n``` {.python .cell-code}\nfrom fastapi import FastAPI, Header, Query\n\napp = FastAPI()\n\n@app.get(\"/calculator/{operator}\")  # <== path parameter\ndef read_item(operator: str, \n              a: int = Query(),     # <== query parameter\n              b: int = Query(),     # <== query parameter\n              h: str = Header()):   # <== header parameter\n    if operator == \"add\":\n        result = a + b\n    elif operator == \"sub\":\n        result = a - b\n    elif operator == \"mul\":\n        result = a * b\n    elif operator == \"div\":\n        result = a / b\n    return {\n        \"operator\": operator,\n        \"a\": a,\n        \"b\": b,\n        \"result\": result,\n        \"h\": h\n    }\n```\n:::\n\n\nSave that to a file called `paramsapi.py`, then start the server by opening a terminal and running:\n```{bash}\npython -m fastapi dev paramsapi.py\n```\n\nAgain, copy the URL. Now in your Jupyter notebook, run the following (replacing the base URL with what you copied):\n\n::: {#27c42563 .cell execution_count=4}\n``` {.python .cell-code}\nbaseurl = 'REPLACE_WITH_COPIED_URL'\noperator = 'add'\nurl = baseurl + 'calculator/' + operator\nparams = {'a': 1, 'b': 2}\nheaders = {'h': 'A header'}\nresponse = requests.get(url, params=params, headers=headers)\nresponse.raise_for_status()\nprint(response.json())\n```\n:::\n\n\nThis will test the `add` method. To try the other methods, change what `operator` is set to. Notice that in doing so, we're changing the URL.\n\n\n::: {.callout-note}\nTo see the signficance of type hints in defining API functions, try removing the type hint from your `paramsapi.py` then run the `requests.get` function in your Jupyter notebook again (note that you don't have to restart the server: FastAPI will detect the change to the code as soon as you save the changes, and automatically restart the server). In other words, try changing:\n\n::: {#21e99932 .cell execution_count=5}\n``` {.python .cell-code}\ndef read_item(operator: str,\n              a: int = Query(),\n              b: int = Query(),\n              h: str = Header()):\n```\n:::\n\n\nto\n\n::: {#7101f70e .cell execution_count=6}\n``` {.python .cell-code}\ndef read_item(operator,\n              a = Query(),\n              b = Query(),\n              h = Header()):\n```\n:::\n\n\nsave the changes, then re-run the `requests.get` for the `add` function in your notebook. Note the type of the returned `a`, `b`, and what the `result` is now: you should see that the returned `a`, `b` are strings (even though you passed in ints) and the result is now the string `\"12\"` rather than the integer 3. This is because FastAPI has assumed all the inputs are strings when you don't provide type hints, so the function does `\"1\" + \"2\" = \"12\"` (why `\"12\"`?) instead of `1 + 2 = 3`. Now add back the type hints to fix your code.\n:::\n\n## Handling Errors\n\nRemember status codes are a way to communicate the status of a request to the client. Here is  list of the standard codes and what they mean:\n\n[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)\n\nError codes are a design contract which means you SHOULD use them as they are EXPECTED, but they are not REQURED.\n\nFastAPI makes it easy to handle errors. You can use the `HTTPException` (which you need to import from `fastapi`) to raise an error with a specific status code and message.\n\nTo illustrate, here's our operator API from above, with a check added to make sure the provided operator is recognized:\n\n::: {#68a27d6c .cell execution_count=7}\n``` {.python .cell-code}\nfrom fastapi import FastAPI, Header, Query, HTTPException\n\napp = FastAPI()\n\n@app.get(\"/calculator/{operator}\")  # <== path parameter\ndef read_item(operator: str, \n              a: int = Query(),     # <== query parameter\n              b: int = Query(),     # <== query parameter\n              h: str = Header()):   # <== header parameter\n    if operator == \"add\":\n        result = a + b\n    elif operator == \"sub\":\n        result = a - b\n    elif operator == \"mul\":\n        result = a * b\n    elif operator == \"div\":\n        result = a / b\n    else:\n        raise HTTPException(status_code=404, \n            detail=\"Operator not found. should be: add, sub, mul, div\")\n    return {\n        \"operator\": operator,\n        \"a\": a,\n        \"b\": b,\n        \"result\": result,\n        \"h\": h\n    }\n```\n:::\n\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 3.1\n\nDesign and build an API to search for  flights (depart/arrive) by Airport Code. \n\nUse this dataset to get the source of your flights:\n\nhttps://raw.githubusercontent.com/mafudge/datasets/refs/heads/master/flights/sample-flights.csv\n\nHere's some examples of the the API endpoint you need to build:\n\n```{text}\n/api/flights/search?type=dep&code=OKA\n/api/flights/search?type=arr&code=KEY\n```\n\nHave your code raise an HTTP Error with status code 400 if the requested type is not `dep` (for departures) or `arr` (for arrivals).\n\nTest your API using the Swagger UI.\n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n::: {#d8258478 .cell execution_count=8}\n``` {.python .cell-code}\nfrom fastapi import FastAPI, Body, HTTPException\nimport pandas as pd\n\n\ndf = pd.read_csv(\"https://raw.githubusercontent.com/mafudge/datasets/refs/heads/master/flights/sample-flights.csv\")\napp = FastAPI()\n\n\n@app.get(\"/api/flights/search\")\ndef search_flights(type: str, code: str):\n    '''\n    Search for flights by origin and destination\n    '''\n    if type == \"dep\":\n        flights = df[df[\"departure_airport_code\"] == code]\n    elif type == \"arr\":\n        flights = df[df[\"arrival_airport_code\"] == code]\n    else:\n        raise HTTPException(status_code=400, detail=\"Invalid type. Must be 'dep' or 'arr'\")\n    return flights.to_dict(orient=\"records\")\n```\n:::\n\n\n:::\n::::\n\n",
    "supporting": [
      "webapi-3_files"
    ],
    "filters": [],
    "includes": {}
  }
}