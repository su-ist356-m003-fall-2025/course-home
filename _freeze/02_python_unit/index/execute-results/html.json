{
  "hash": "65aec6d7c869eec4aeee324846109cb4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Example Python Unit\"\nsubtitle: \"[UNIT LONG NAME]\"\ntoc: true\norder: 2\nexecute:\n  error: true\n---\n\nThis Python tutorial will cover the basics of\n\n - basic types in Python\n - container types\n - control flow\n\n## Types in computing\n\nIn computing, we deal with values, different numbers, text, images (which are numbers), boolean (logical). These values need to be represented in the memory of a computer, that is a number of binary switches (\"0's and 1's\").\n\n### Integers\n\nA simple example is an integer number that can be expressed in the base2 (in the example, using 4 \"bits\"): 0001 is 1 in decimal, 0101 is (from left to right $0\\cdot2^3 + 1\\cdot2^2 + 0\\cdot2^1 + 1 \\cdot 2^0(=1) = 5$. Using enough bits, we can represent any integer number (and use, for example, the leftmost bit as a flag to indicate that a minus is in front of it in order to produce a negative number). Technically, the types encountered are usually called int32, int64 (being the most common ones, but others exist too), where the trailing number indicates the number of bits used. In Python, we do not need to take care of it and integers are \"precise enough\". A huge advantage of using Python!\n\n**Comparing integer numbers is always correct**, because each integer has one, and exactly one representation.\n\n### Strings (aka text)\n\nHaving defined integers, it's easy to define text: each letter corresponds to an integer number (hidden to us users). All that is needed is something that marks a stream of bites as \"text\" and then evaluates that a certain number corresponds to a letter.\n\n### Floating point numbers\n\nThis is where things get a bit tricky: while there is exactly one integer between the integers 4 and 6, for example, there are infinitly many floating point numbers between, say 3.1 and 3.2 and the number of digits can easily be large. This leads to a practical problem: **we cannot accurately represent floating point numbers!** 3.1 maybe is not equal to 3.1!\n\nFloating point numbers consist of two parts: an \"integer-like\" part, that is, a numeric value. And another part that defines the _exponent_ of a base that the numerical value is multiplied by.\n\nImagine that every float is like an integer, \"shifted\" to the left or right.\n\nThe types are usually called float32 or float64 (and more). Usually, use float64 if ever needed for any scientific computing (machine learning being a notable exception).\n\nA number like 10/3 needs infinitely many digits to represent it _exactly_, but due to the limited precision that can be stored, it will be truncated in the computer.\nTherefore $(10 / 3) \\cdot 3$ equals $10$, but a computer will return a number like 9.99999999 (with many, typically 8 or 16 digits for a float 32 or float64 respectively), but limited.\n\n(Python sometimes tries to hide this fact with some numbers, but nothing to rely on)\n\nAnother consequence is limited precision: adding a very small number to a very large one (i.e. if the small one is smaller than the precision that the large one is stored with, the small one will be \"ignored\", as it first has to be converted to the same representation as the large one.\n\n## Basic types and operations\n\nPython has several basic types\n - numerical (float, int, complex)\n - string\n - bool\n \nThere are several operations defined on them, as we have already seen in examples.\n\n::: {#1d2407ca .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=1}\n``` {.python .cell-code}\na = 1  # creates an integer\n\nb = 3.4  # float\n\n# several ways for strings\nc = \"hello\"\nd = 'world'\ncd = \"welcome to this 'world' here\"  # we can now use '' inside (or vice versa)\ne = \"\"\"hello world\"\"\"  # which we can also wrap\ne2 = \"\"\"hello\nworld\ncome here!\"\"\"\n\ng = True\n\nprint(a, b, c, d, cd, e)\nprint(e2)\nprint(g)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 3.4 hello world welcome to this 'world' here hello world\nhello\nworld\ncome here!\nTrue\n```\n:::\n:::\n\n\n::: {#36b2ca1a .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=2}\n``` {.python .cell-code}\n  type(a) \n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nint\n```\n:::\n:::\n\n\nWith `type(...)`, we can determine the type of an object.\n\n## strong typing\n\nPython is **strongly typed**. This means that the type of the variable _matters_ and some interactions between certain types are not directly possible.\n\n::: {#1cc167a0 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=3}\n``` {.python .cell-code}\na = 1\nb = 2\n```\n:::\n\n\n::: {#c094d564 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=4}\n``` {.python .cell-code}\na + b\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n3\n```\n:::\n:::\n\n\n These are two integers. We are not surprised that this works. What about the following?\n\n::: {#9882c46a .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' tags='[\"raises-exception\"]' execution_count=5}\n``` {.python .cell-code}\nmix_str_int = a + \"foo\"\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[5]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> mix_str_int = <span class=\"ansi-yellow-bg\">a</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-bg\">+</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-fg ansi-yellow-bg\">\"</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">foo</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">\"</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: unsupported operand type(s) for +: 'int' and 'str'</pre>\n```\n:::\n\n:::\n:::\n\n\nMaybe the following works?\n\n::: {#caecf749 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' tags='[\"raises-exception\"]' execution_count=6}\n``` {.python .cell-code}\nmix_str_int2 = a + \"5\"\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[6]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> mix_str_int2 = <span class=\"ansi-yellow-bg\">a</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-bg\">+</span><span class=\"ansi-yellow-bg\"> </span><span class=\"ansi-yellow-fg ansi-yellow-bg\">\"</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">5</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">\"</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: unsupported operand type(s) for +: 'int' and 'str'</pre>\n```\n:::\n\n:::\n:::\n\n\nPython is strict on the types, but we can sometimes convert from one type to another, explicitly:\n\n::: {#31cd6a35 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=7}\n``` {.python .cell-code}\na + int(\"5\")\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n6\n```\n:::\n:::\n\n\n...which works because `int(\"5\") -> 5`.\n\nThere are though some implicit conversions in Python, let's look at the following:\n\n::: {#5a31ac3d .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=8}\n``` {.python .cell-code}\nf = 1.2\nprint(type(f))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'float'>\n```\n:::\n:::\n\n\n::: {#bbb118f3 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=9}\n``` {.python .cell-code}\nint_plus_float = a + f\nprint(type(int_plus_float))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'float'>\n```\n:::\n:::\n\n\nThis is one of the few examples, where Python automatically converts the integer type to a float. The above addition _actually_ reads as\n\n::: {#3341561d .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=10}\n``` {.python .cell-code}\nint_plus_float = float(a) + f\n```\n:::\n\n\nSimilar with booleans as they are in principle 1 (`True`) and 0 (`False`)\n\n::: {#29588561 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=11}\n``` {.python .cell-code}\nTrue + 5\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n6\n```\n:::\n:::\n\n\nFor readability, it is usually better to write an explicit conversion.\n\n## Container types\n\nPython has several container types as also found in other languages. The most important ones are:\n - list  (~array in other languages)\n - dict  (~hash table in other languages)\n \nThey can contain other objects which can then be assigned and accessed via the `[]` operator _(we will have a closer look at operators later on)_\n\nA list stores elements by indices, which are integers, while a dict stores elements by a `key`, which can be \"any basic type\" (to be precise: by their \"hash\", it can be any immutable type).\n\n::: {#ce8fe14c .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=12}\n``` {.python .cell-code}\n# creating a list\nlist1 = [1, 2, 3]\nprint(list1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3]\n```\n:::\n:::\n\n\nWe can access these element by indices, starting from 0\n\n::: {#5849a06d .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=13}\n``` {.python .cell-code}\nlist1[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\n1\n```\n:::\n:::\n\n\nWe can also assign a value to an place in the list\n\n::: {#d7fa67db .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=14}\n``` {.python .cell-code}\nlist1[1] = 42\nprint(list1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 42, 3]\n```\n:::\n:::\n\n\nand it can be extended with elements\n\n::: {#009aaa99 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=15}\n``` {.python .cell-code}\nlist1.append(-5)\nprint(list1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 42, 3, -5]\n```\n:::\n:::\n\n\nChoosing a value that is not contained in the list raises an error. It is verbose, read and understand it.\n\nBeing able to understand and interpret errors correctly is a key to becoming better in coding.\n\n::: {#1d56dc19 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' tags='[\"raises-exception\"]' execution_count=16}\n``` {.python .cell-code}\nlist1[14]\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">IndexError</span>                                Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[16]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span class=\"ansi-yellow-bg\">list1</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-green-fg ansi-yellow-bg\">14</span><span class=\"ansi-yellow-bg\">]</span>\n\n<span class=\"ansi-red-fg\">IndexError</span>: list index out of range</pre>\n```\n:::\n\n:::\n:::\n\n\nWe can play a similar game with dicts\n\n::: {#5daca64a .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=17}\n``` {.python .cell-code}\nperson = {'name': \"Rafael Silva Coutinho\", 'age': 37, 5: True, 11: \"hi\"}  # we can use strings but also other elements\nprint(person)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'name': 'Rafael Silva Coutinho', 'age': 37, 5: True, 11: 'hi'}\n```\n:::\n:::\n\n\n::: {#8440bf75 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=18}\n``` {.python .cell-code}\nprint(person['name'])\nprint(person[5])\nprint(person[11])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRafael Silva Coutinho\nTrue\nhi\n```\n:::\n:::\n\n\nWe can also assign a new value to a key.\n\n::: {#ff46ec2f .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=19}\n``` {.python .cell-code}\nperson['age'] = '42.00001'\nprint(person)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'name': 'Rafael Silva Coutinho', 'age': '42.00001', 5: True, 11: 'hi'}\n```\n:::\n:::\n\n\n... or even extend it by assigning to a key that did not yet exists in the dict\n\n::: {#fe20767a .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=20}\n``` {.python .cell-code}\nperson['alias'] = \"rsilvaco\"\nprint(person)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'name': 'Rafael Silva Coutinho', 'age': '42.00001', 5: True, 11: 'hi', 'alias': 'rsilvaco'}\n```\n:::\n:::\n\n\nAs we see this works. Notice, that the dict has changed, same as the list before.\n\nAgain, selecting a key that is not contained in the dict raises an error.\n\n::: {#d6c328a3 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' tags='[\"raises-exception\"]' execution_count=21}\n``` {.python .cell-code}\nperson['nationality']\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">KeyError</span>                                  Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[21]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span class=\"ansi-yellow-bg\">person</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">'</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">nationality</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">'</span><span class=\"ansi-yellow-bg\">]</span>\n\n<span class=\"ansi-red-fg\">KeyError</span>: 'nationality'</pre>\n```\n:::\n\n:::\n:::\n\n\nAs any object in Python, there are many useful methods on `list` and `dict` that help you accomplish things. For example, what if we want to retrieve a value from a dict _only_ if the key is there and otherwise return a default value? We can use `get`:\n\n::: {#7433a8b1 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=22}\n``` {.python .cell-code}\nhair_color = person.get('hair_color', 'unknown color')  # the second argument gets returned if key is not in dict\nprint(hair_color)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nunknown color\n```\n:::\n:::\n\n\n## Mutability\n\nPython has a fundamental distinction between mutable and immutable types.\n\nMutable means, an object can be changed\nImmutable means, an object can not be changed\n\nAs an example, `5` can not change; in general the basic types we looked at cannot change. We can change the value that is assigned to a variable, but the object `5` remains the same. The list and dicts we have seen above on the other hand are mutable, they have changed over the course of execution.\n\nEvery mutable object has an immutable counterpart (but not vice-versa):\n - list -> tuple\n - dict -> frozendict\n - set -> frozenset\n - etc.\n\n::: {#30e6b244 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=23}\n``` {.python .cell-code}\n# creating a tuple\ntuple1 = (1, 3, 5)\n# or from a list\ntuple_from_list = tuple(list1)\n```\n:::\n\n\n::: {#8004abba .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=24}\n``` {.python .cell-code}\nlist2 = [4, 5]\ntuple2 = (3, 4)\nlist3 = list(tuple2)\n```\n:::\n\n\n::: {#65b33a2a .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=25}\n``` {.python .cell-code}\nprint(list2)\nprint(tuple2)\nprint(list3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[4, 5]\n(3, 4)\n[3, 4]\n```\n:::\n:::\n\n\nWhile we can access the elements as we can for a list, we can neither _assign_ nor _append_ (or in generate _mutate_ the object:\n\n::: {#7321f3aa .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=26}\n``` {.python .cell-code}\nprint(tuple1[1])  # access works!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n```\n:::\n:::\n\n\n::: {#83661af4 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' tags='[\"raises-exception\"]' execution_count=27}\n``` {.python .cell-code}\ntuple1[0] = 5\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[27]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span class=\"ansi-yellow-bg\">tuple1</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-green-fg ansi-yellow-bg\">0</span><span class=\"ansi-yellow-bg\">]</span> = <span class=\"ansi-green-fg\">5</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: 'tuple' object does not support item assignment</pre>\n```\n:::\n\n:::\n:::\n\n\nWe will soon see the effects and needs for this...\n\n**Exercise**\n\nCreate a list with 3 elements. Then create a tuple with 5 elements, one of them being the list.\nChange an element in the list. Did it change in the tuple? Do you understand this?\n\n::: {#6dd26d31 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=28}\n``` {.python .cell-code}\nmy_list = [1, 2, 3]\nmy_tuple = (4, 5, my_list, 7, 8)\n```\n:::\n\n\n::: {#c052addd .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=29}\n``` {.python .cell-code}\nmy_list[0] = 8   \nprint(my_tuple)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(4, 5, [8, 2, 3], 7, 8)\n```\n:::\n:::\n\n\n## Dynamic typing\n\nPython is dynamically typed. This means that a variable, which once was an int, such as `a`, can be assigned a value of another type (this maybe sounds trivial, but this is not possible to do in many other languages).\n\n::: {#d150dfab .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=30}\n``` {.python .cell-code}\na = 1\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n```\n:::\n:::\n\n\n::: {#2734398c .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=31}\n``` {.python .cell-code}\na = \"one\"\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\none\n```\n:::\n:::\n\n\n::: {#ecd74f8b .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=32}\n``` {.python .cell-code}\na = list1\nprint(a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 42, 3, -5]\n```\n:::\n:::\n\n\n... and so on\n\n# Assignement and variables\n\nWe've seen a few things up to now but have not really looked at the assignement and variables itself. Understanding Pythons variable is crucial to understand e.g. the following:\n\n::: {#b2bc4851 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=33}\n``` {.python .cell-code}\na = 5\nb = a\nprint(a, b) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5 5\n```\n:::\n:::\n\n\n::: {#14915aaf .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=34}\n``` {.python .cell-code}\na = 3\nprint(a, b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3 5\n```\n:::\n:::\n\n\nSo far so good, no surprise here.\n\n::: {#ded87a6f .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=35}\n``` {.python .cell-code}\nlist1 = [1, 3]\nlist2 = list1\nprint(list1, list2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 3] [1, 3]\n```\n:::\n:::\n\n\n::: {#6f674540 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=36}\n``` {.python .cell-code}\nlist2[0] = 99\nprint(list1, list2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[99, 3] [99, 3]\n```\n:::\n:::\n\n\n...but that was probably unexpected! Let's have a look at Pythons variable assignement.\n\n## Python variable assignement\n\nAssigning something to a variable in Python makes a name point to an actual object, so the name is only a reference. For example creating the variable `a` and assigning it the object `5` looks like this:\n![assignements1](figs/python_references1.jpg)\n\n::: {#d6d65427 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=37}\n``` {.python .cell-code}\na = 3\nlist_a = [1, 2]\nprint(a)\nprint(list_a)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n[1, 2]\n```\n:::\n:::\n\n\n![reference2](figs/python_references2.jpg)\n\n::: {#587ae927 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=38}\n``` {.python .cell-code}\nb = a  # this assigns the reference of a to b\nlist_b = list_a\nprint(a, b)\nprint(list_a, list_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3 3\n[1, 2] [1, 2]\n```\n:::\n:::\n\n\nBoth objects, `b` and `list_b` point now to the same objects in memory as `a` and `list_a` respectively. Re-assigning a variable let's it point to a different object\n![reference3](figs/python_references3.jpg)\n\n::: {#ea392e1c .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' tags='[]' execution_count=39}\n``` {.python .cell-code}\na = 'spam'\nlist_a = [1, 5, 2, 'world', 1]\nprint(a, b)\nprint(list_a, list_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspam 3\n[1, 5, 2, 'world', 1] [1, 2]\n```\n:::\n:::\n\n\nLet's make them point to the same object again:\n\n::: {#d8f9c130 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=40}\n``` {.python .cell-code}\nb = a\nlist_b = list_a \nprint(a, b)\nprint(list_a, list_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nspam spam\n[1, 5, 2, 'world', 1] [1, 5, 2, 'world', 1]\n```\n:::\n:::\n\n\n::: {#7b85476c .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=41}\n``` {.python .cell-code}\nlist_a[1] = 'hello'\nprint(list_a, list_b)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 'hello', 2, 'world', 1] [1, 'hello', 2, 'world', 1]\n```\n:::\n:::\n\n\nNow we understand what happend: the object that both variables are pointing to simply changed. This is impossible with immutable objects (such as `3`), since they are immutable.\n\nMutable objects usually offer the ability to create a copy.\n\n::: {#b75ae2ec .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=42}\n``` {.python .cell-code}\nlist_c = list_a.copy()  # now there are two identical lists in the memory\n```\n:::\n\n\n::: {#94957ed3 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=43}\n``` {.python .cell-code}\nlist_a[2] = 'my'\nprint(list_a)\nprint(list_b)\nprint(list_c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 'hello', 'my', 'world', 1]\n[1, 'hello', 'my', 'world', 1]\n[1, 'hello', 2, 'world', 1]\n```\n:::\n:::\n\n\n`list_a` and `list_b`, pointing to the same object that was mutated, have changed, while `list_c`, pointing to a different object, remained the same.\n\nLet's have a look at two operators: the \"trivial\" `==` and the `is`:\nwe know `==` pretty well, it tells whether the left and the right side are the same. More specific, it tells whether both sides have/represent the same _value_, not whether they are in fact the same object!\nThe operator `is` tells us, whether two objects _are_ the same object (compare our assignement model above!).\n\n::: {#b14e8a32 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=44}\n``` {.python .cell-code}\nprint(list_a == list_c)  # not the same\nprint(list_a == list_b)  # the same\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\n```\n:::\n:::\n\n\n::: {#ff638620 .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=45}\n``` {.python .cell-code}\nlist_c[2] = 'my'  # make it the same as the other lists\nprint(list_a == list_c)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\nBut, as we learned before, they are _not the same objects_!\n\n::: {#25e3efcf .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=46}\n``` {.python .cell-code}\nprint(list_a is list_c)  # nope!\nprint(list_a is list_b)  # yes!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFalse\nTrue\n```\n:::\n:::\n\n\nUsually, we are interested to compare the values, using `==` (notable exception: checking, if a value is `None` means to check using the identity equality `is`.\n\nExercise 2: Create a list a = [1, 2, 3] and create a new variable b and assign it to a. Compare a and b using == and is. Print the results. Modify a by appending 4 to it and print b. Do you understand why you have this solution?\n\n::: {#7e9d593a .cell quarto-private-1='{\"key\":\"slideshow\",\"value\":{\"slide_type\":\"subslide\"}}' execution_count=47}\n``` {.python .cell-code}\n# Step 1: Create a list\na = [1, 2, 3]\n\n# Step 2: Assign a to b\nb = a\n\n# Step 3: Compare a and b using == and is\nprint(\"a == b:\", a == b)  # Expected output: True\nprint(\"a is b:\", a is b)  # Expected output: True\n\n# Step 4: Modify a by appending 4\na.append(4)\n\n# Step 5: Print b\nprint(\"b:\", b)  # Expected output: [1, 2, 3, 4]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na == b: True\na is b: True\nb: [1, 2, 3, 4]\n```\n:::\n:::\n\n\nExplanation:\n\na == b and a is b are both True because b is assigned directly from a, meaning they refer to the same list object.\nAfter appending 4 to a, b also changes because both a and b point to the same list in memory.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}